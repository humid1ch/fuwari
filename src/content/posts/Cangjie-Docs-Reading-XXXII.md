---
title: "仓颉文档阅读-开发指南III: 基础数据类型(II) - 整型、浮点型和布尔类型"
published: 2025-10-28 13:43:12
description: "仓颉文档阅读的开发指南部分, 本篇文章介绍一些仓颉语言的一些基础类型: 整型、浮点型和布尔类型"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
category: Blogs
tags:
    - 开发语言
    - 仓颉
---

> [!NOTE]
> 
> 阅读文档版本:
> 
> 语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)
> 
> 具体开发指南 [Cangjie-LTS-1.0.3](https://cangjie-lang.cn/docs?url=/1.0.3/index.html) 
> 
> 在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用 [仓颉在线体验](https://cangjie-lang.cn/playground) 快速验证
> 
> 有条件当然可以直接 [配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.3) 

> [!WARNING]
> 
> 博主在此之前, 基本只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅
> 
> 且, 本系列是文档阅读, 而不是仓颉的零基础教学, 所以如果要跟着阅读的话最好有一门编程语言的开发经验

> [!WARNING]
> 
> 在阅读仓颉编程语言的开发指南之前, 已经大概阅读了一遍 仓颉编程语言的语言规约, 已经对仓颉编程语言有了一个大概的了解
> 
> 所以在阅读开发指南时, 不会对类似: 类、函数、结构体、接口等解释起来较为复杂名称 做出解释

> 此样式内容, 表示文档原文内容

## 基础数据类型

### 整数类型

> 整数类型分为有符号(`signed`)整数类型和无符号(`unsigned`)整数类型
>
> 有符号整数类型包括`Int8`、`Int16`、`Int32`、`Int64`和`IntNative`, 分别用于表示编码长度为`8-bit`、`16-bit`、`32-bit`、`64-bit`和平台相关大小的有符号整数值的类型
>
> 无符号整数类型包括`UInt8`、`UInt16`、`UInt32`、`UInt64`和`UIntNative`, 分别用于表示编码长度为`8-bit`、`16-bit`、`32-bit`、`64-bit`和平台相关大小的无符号整数值的类型
>
> 对于编码长度为`N`的有符号整数类型, 其表示范围为: $ −2 ^ {N−1} ∼ 2 ^ {N−1} − 1$
>
> 对于编码长度为`N`的无符号整数类型, 其表示范围为: $ 0 ∼ 2 ^ {N} −1$
>
> 下表列出了所有整数类型的表示范围:
>
> | 类型 | 表示范围 |
> | ---- | -------- |
> | `Int8` | $ −2 ^ {7} ∼ 2 ^ {7} − 1 (−128 ∼ 127) $ |
> | `Int16` | $ −2 ^ {15} ∼ 2 ^ {15} − 1 (−32,768 ∼ 32,767) $ |
> | `Int32` | $ −2 ^ {31} ∼ 2 ^ {31} − 1 (−2,147,483,648 ∼ 2,147,483,647) $ |
> | `Int64` | $ −2 ^ {63} ∼ 2 ^ {63} − 1 (−9,223,372,036,854,775,808 ∼ 9,223,372,036,854,775,807) $ |
> | `IntNative` | `Platform dependent` |
> | `UInt8` | $ 0 ∼ 2 ^ {8} − 1 (0 ∼ 255) $ |
> | `UInt16` | $ 0 ∼2 ^ {16} − 1 (0 ∼ 65,535) $ |
> | `UInt32` | $ 0 ∼ 2 ^ {32} − 1 (0 ∼ 4,294,967,295) $ |
> | `UInt64` | $ 0 ∼ 2 ^ {64} − 1 (0 ∼ 18,446,744,073,709,551,615) $ |
> | `UIntNative` | `Platform dependent` |
>
> 程序具体使用哪种整数类型, 取决于该程序中需要处理的整数的性质和范围
>
> 在`Int64`类型适合的情况下, 首选`Int64`类型, 因为`Int64`的表示范围足够大
>
> 并且 **[整数类型字面量]()** 在没有类型上下文的情况下**默认推断为`Int64`类型**, 可以避免不必要的类型转换

仓颉中整数类型根据位数和有无符号共分为10种, 其中两种`IntNative`和`UIntNative`与平台相关

仓颉中的整型字面量, 在没有上下文时, 默认为`Int64`类型, 即: 类似`let value = 20`, `value`就是`Int64`类型

#### 整数类型字面量

> 整数类型字面量有`4`种进制表示形式: 二进制(使用`0b`或`0B`前缀)、八进制(使用`0o`或`0O`前缀)、十进制(没有前缀)、十六进制(使用`0x`或`0X`前缀)
>
> 例如, 对于十进制数`24`, 表示成二进制是`0b00011000`(或`0B00011000`), 表示成八进制是`0o30`(或`0O30`), 表示成十六进制是`0x18`(或`0X18`)
>
> 在各进制表示中, 可以使用下划线`_`充当分隔符的作用, 方便识别数值的位数, 如`0b0001_1000`
>
> 对于整数类型字面量, 如果它的值超出了上下文要求的整数类型的表示范围, 编译器将会报错
>
> ```cangjie
> let x: Int8 = 128               // Error, 128 out of the range of Int8
> let y: UInt8 = 256              // Error, 256 out of the range of UInt8
> let z: Int32 = 0x8000_0000      // Error, 0x8000_0000 out of the range of Int32
> ```
>
> 在使用整数类型字面量时, 可以通过加入后缀来明确整数字面量的类型, 后缀与类型的对应为:
>
> | 后缀 | 类型 | 后缀 | 类型 |
> | ---- | ---- | ---- | ---- |
> | `i8` | `Int8` | `u8` | `UInt8` |
> | `i16` | `Int16` | `u16` | `UInt16` |
> | `i32` | `Int32` | `u32` | `UInt32` |
> | `i64` | `Int64` | `u64` | `UInt64` |
>
> 加入了后缀的整数字面量可以通过以下方式使用:
>
> ```cangjie
> var x = 100i8                   // x 是 100  Int8 类型
> var y = 0x10u64                 // y 是 16  UInt64 类型
> var z = 0o432i32                // z 是 282  Int32 类型
> ```

仓颉中的整型字面量支持: 二进制、八进制、十进制和十六进制

并且, 可以使用`_`进行分割, 不影响数值, 同时可以使用后缀明确类型:

```cangjie
// 二进制 需要加前缀 0b/0B
0b00001111
0b00001111i8
0b00001111_i8
0b0000_1111_i8
0b0000_1111_u8

// 八进制 需要加前缀 0o/0O
0o76543
0o76543i16
0o76543_i16
0o76_543_i16
0o76_543_u16

// 十进制 无前缀
12345678
12345678i32
12345678_i32
12_345_678_i32
12_345_678_u32

// 十六进制 需要加前缀 0x/0X
0xFE
0xFEi8
0xFE_i8
0xFE_DC_i16
0xFE_DC_u16
```

#### 字符字节字面量

> 仓颉编程语言支持**字符字节字面量**, 以方便使用`ASCII`码表示`UInt8`类型的值
>
> 字符字节字面量由字符`b`、一对标识首尾的单引号、以及一个`ASCII`字符组成, 例如:
>
> ```cangjie
> var a = b'x'                          // a is 120 with type UInt8
> var b = b'\n'                         // b is 10 with type UInt8
> var c = b'\u{78}'                     // c is 120 with type UInt8
> c = b'\u{90}' - b'\u{66}' + c         // c is 162 with type UInt8
> ```
>
> `b'x'`表示类型为`UInt8`大小是`120`的字面值
>
> 另外还可以通过`b'\u{78}'`这种转义形式表示类型为`UInt8`, `16`进制大小为`0x78`或`10`进制大小为`120`的字面值
>
> 需要注意的是, `\u`内部最多有两位`16`进制数, 并且值必须小于`256`(十进制)

仓颉中存在字符字节字面量, 不是字符字面量, 而不是字符串字面量

而是一`b'ASCII'`形式的字符字节字面量, `''`包裹的内容必须是`ASCII`表中的字符, 或`\u{二位十六进制 < 256}`

#### 整数类型支持的操作

> 整数类型默认支持的操作符包括: 算术操作符、位操作符、关系操作符、自增和自减操作符、复合赋值操作符
>
> 各操作符的优先级参见附录中的操作符
>
> 1. 算术操作符包括: 一元负号(`-`)、加法(`+`)、减法(`-`)、乘法(`*`)、除法(`/`)、取模(`%`)、幂运算(`**`)
>
>     - 除了一元负号(`-`)和幂运算(`**`), 其他操作符要求左右操作数是相同的类型
>
>     - `*`, `/`, `+`和`-`的操作数可以是整数类型或浮点类型
>
>     - `%`的操作数只支持整数类型
>
>     - `**`的左操作数只能为`Int64`类型或`Float64`类型, 并且:
>
>         - 当左操作数类型为`Int64`时, 右操作数只能为`UInt64`类型, 表达式的类型为`Int64`
>
>         - 当左操作数类型为`Float64`时, 右操作数只能为`Int64`类型或`Float64`类型, 表达式的类型为`Float64`
>
> 2. 位操作符包括: 按位求反(`!`)、左移(`<<`)、右移(`>>`)、按位与(`&`)、按位异或(`^`)、按位或(`|`)
>
>     注意, 按位与、按位异或和按位或操作符要求左右操作数是相同的整数类型
>
> 3. 关系操作符包括: 小于(`<`)、大于(`>`)、小于等于(`<=`)、大于等于(`>=`)、相等(`==`)、不等(`!=`)
>
>     要求关系操作符的左右操作数是相同的整数类型
>
> 4. 自增和自减操作符包括: 自增(`++`)和自减(`--`)
>
>     注意, 仓颉中的自增和自减操作符只能作为一元后缀操作符使用
>
> 5. 复合赋值操作符包括:`+=`、`-=`、`*=`、`/=`、`%=`、`**=`、`<<=`、`>>=`、`&=`、`^=`、`|=`
>
> 整数类型之间、整数类型和浮点类型之间可以互相转换, 整数类型可以转换为字符类型, 具体的类型转换语法及规则请参见[数值类型之间的转换]
>
> > 注意:
> >
> > 本章所提及的某个类型支持的操作, 均是指在**没有操作符重载的前提下**

仓颉的整数类型、浮点类型之间可以相互**显式转换**, 整数类型也可以转换成目标字符类型, 但 都需要遵循类型转换的语法规则

### 浮点类型

> 浮点类型包括`Float16`、`Float32`和`Float64`, 分别用于表示编码长度为`16-bit`、`32-bit`和`64-bit`的浮点数(带小数部分的数字, 如`3.14159`、`8.24`和`0.1`等)的类型
>
> `Float16`、`Float32`和`Float64`分别对应`IEEE 754`中的半精度格式(即`binary16`)、单精度格式(即`binary32`)和双精度格式(即`binary64`)
>
> `Float64`的精度(有效数字位)约为`15`位, `Float32`的精度(有效数字位)约为`6`位, `Float16`的精度(有效数字位)约为`3`位
>
> 使用哪种浮点类型, 取决于代码中需要处理的浮点数的性质和范围
>
> 在多种浮点类型都适合的情况下, 首选精度高的浮点类型, 因为精度低的浮点类型的累计计算误差很容易扩散, 并且它能精确表示的整数范围也很有限

浮点数, 即小数

目前, 绝大多数的现代编程语言对于浮点数的规定都遵循`IEEE 754`标准

针对不同的浮点精度, 仓颉中存在三种浮点类型:`Float16``Float32``Float64`, 分别对应 半精度、单精度和双精度

对应的有效位精度为`3`位、`6`位和`15`位

这是什么意思呢?

精度的位数, 表示浮点数可靠位数, **包括整数位和小数位**

如果存在一个浮点数字面量:`123.1234567890123456789`

那么, 将此字面量赋值到三种不同的浮点类型时, 数据位的可靠程度是不同的:

1. `Float16`:

    ```cangjie
    let half: Float16 = 123.1234567890123456789
    println(half.format(".20"))
    ```

1. `Float32`:

    ```cangjie
    let single: Float32 = 123.1234567890123456789
    println(single.format(".20"))
    ```

3. `Float64`:

    ```cangjie
    let double: Float64 = 123.1234567890123456789
    println(double.format(".20"))
    ```

这三个变量打印的结果是不同的:

打印结果截图

可以看到:

1. 对于`Float16`, 对于整个十进制数, 只有`5`位是准确的:`3`位整数, `2`位小数

2. 对于`Float32`, 对于整个十进制数, 有`8`位是准确的:`3`位整数, `5`位小数

3. 对于`Float64`, 对于整个十进制数, 有`16`位是准确的:`3`位整数, `13`位小数

为什么与文档不保持一致呢?

答案其实很简单, 因为文档的精度, 说明的是绝对准确的位数, 而打印的数据后面几位可能并不是绝对的精准, 显示只是在不精准之后, 恰好"精准"了

如果数据变了, 可能打印出来的"精度"可能就会变化, 但 **前`3``6``15`位的精度是绝对的**

所以使用浮点数时, 要按照精度进行使用

**精度并不仅表示小数位精度, 而是指整个完整的浮点数, 包括整数部分和小数部分**

> [!NOTE]
> 
> 仓颉中, 使用`print`和`println`直接打印浮点类型数据, 默认最多保留6位小数:
> 
> ```cangjie
> let value = 123.1234567890
> println(value)
> ```
> 
> 但可以通过`FloatN.format()`接口, 调整输出小数位
> 
> 不过在使用前需要导入`std.convert.Formattable`接口
> 
> ```cangjie
> import std.convert.Formattable
> 
> let value = 123.1234567890
> println(value.format(".10"))
> ```

#### 浮点类型字面量

> 浮点类型字面量有两种进制表示形式: 十进制、十六进制
>
> 在十进制表示中, 一个浮点字面量至少要包含一个整数部分或一个小数部分, 没有小数部分时必须包含指数部分(以`e`或`E`为前缀, 底数为`10`)
>
> 在十六进制表示中, 一个浮点字面量除了至少要包含一个整数部分或小数部分(以`0x`或`0X`为前缀), 同时必须包含指数部分(以`p`或`P`为前缀, 底数为`2`)
>
> 下面的例子展示了浮点字面量的使用:
>
> ```cangjie
> let a: Float32 = 3.14         // a is 3.140000 with type Float32
> let b: Float32 = 2e3          // b is 2000.000000 with type Float32
> let c: Float32 = 2.4e-1       // c is 0.240000 with type Float32
> let d: Float64 = .123e2       // d is 12.300000 with type Float64
> let e: Float64 = 0x1.1p0      // e is 1.062500 with type Float64
> let f: Float64 = 0x1p2        // f is 4.000000 with type Float64
> let g: Float64 = 0x.2p4       // g is 2.000000 with type Float64
> ```
> 在使用十进制浮点数字面量时, 可以通过加入后缀来明确浮点数字面量的类型, 后缀与类型的对应为:
>
> | 后缀 | 类型 |
> | ---- | ---- |
> | `f16` | `Float16` |
> | `f32` | `Float32` |
> | `f64` | `Float64` |
>
> 加入了后缀的浮点数字面量可以像下面的方式来使用:
>
> ```cangjie
> let a = 3.14f32               // a is 3.140000 with type Float32
> let b = 2e3f32                // b is 2000.000000 with type Float32
> let c = 2.4e-1f64             // c is 0.240000 with type Float64
> let d = .123e2f64             // d is 12.300000 with type Float64
> ```

仓颉的浮点类型字面量, 除了一般的十进制小数之外, 十进制和十六进制浮点数均可分为: 整数部分、小数部分和指数部分, 指数部分与前两部分相乘

十进制, 还可以使用`e/E`表示指数部分(没有小数部分时, 指数部分为必须), `eN`表示以`10`为底的`N`次幂, `N`为整数

十六进制, 则必须存在使用`p/P`表示指数部分, `pN`表示以`2`为底的`N`次幂, `N`为整数

#### 浮点类型支持的操作

> 浮点类型默认支持的操作符包括: 算术操作符、关系操作符、复合赋值操作符
>
> 浮点类型**不支持自增和自减操作符**
>
> 浮点类型之间、浮点类型和整数类型之间可以互相转换, 具体的类型转换语法及规则请参见[数值类型之间的转换]()

### 布尔类型

> 布尔类型使用`Bool`表示, 用来表示逻辑中的真和假

#### 布尔类型字面量

> 布尔类型只有两个字面量:`true`和`false`
>
> 下面的例子展示了布尔字面量的使用:
>
> ```cangjie
> let a: Bool = true
> let b: Bool = false
> ```

#### 布尔类型支持的操作

> 布尔类型支持的操作符包括: 逻辑操作符(逻辑非`!`, 逻辑与`&&`, 逻辑或`||`)、部分关系操作符(`==`和`!=`)、部分复合赋值操作符(`&&=`和`||=`)

布尔类型支持的操作, 基本都是关系和逻辑操作符

布尔类型禁止与其他类型发生类型转换
